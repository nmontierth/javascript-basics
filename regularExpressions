Before you read over my notes. These notes are taken based on Ch9 Regular Expressions here: https://eloquentjavascript.net/09_regexp.html
Also... I HIGHLY recommend this site: https://regexr.com/ for better understanding and testing RegExp as you learn

Regular Expressions --> A way to describe patterns in string data (type of object).

SYNTAX
Two ways to construct:
    1) let re1 = new RegExp("abc");
    2) let re2 = /abc/;
    
 For 2)... since forward slashes end the statement, any forward slashes that should be included within the statement should be 
 preceded by a back slach and vice versa. Same applies for some characters such as + and ?.
 
 TESTING FOR MATCHES
      console.log(/abc/.test("abcde"));
      // → true
      console.log(/abc/.test("abxde"));
      // → false
    
 SETS OF CHARACTERS
 Does a string contain digits??? Here's a way to test:
      console.log(/[0123456789]/.test("in 1992"));
      // → true
      console.log(/[0-9]/.test("in 1992"));
      // → true
 The hyphen between brackets indicates a range of characters... of course its referencing the character's Unicode numbers... in this 
 case-- characters 0-9 represent codes 48 to 57.
 
 Shortcuts for character groups: 
      \d	Any digit character
      \w	An alphanumeric character (“word character”)
      \s	Any whitespace character (space, tab, newline, and similar)
      \D	A character that is not a digit
      \W	A nonalphanumeric character
      \S	A nonwhitespace character
      .	Any character except for newline
      []  Enclosing backslash codes in square brackets causes special characters to lose their meaning (.,+,etc.) this is useful 
      when scanning for these characters specifically
      [^] Inverts a set of characters (match any character EXCEPT the ones in the set (ex. /[^01]/ will match any non binary inputs)
      
 An example where this is useful:
      let dateTime = /\d\d-\d\d-\d\d\d\d \d\d:\d\d/;
      console.log(dateTime.test("01-30-2003 15:20"));
      // → true
      console.log(dateTime.test("30-jan-2003 15:20"));
      // → false
 
 REPEATING PARTS OF A PATTERN (ALWAYS COMES AFTER THE CHARACTER)
 + --> it can be expressed more than once
 * --> same as + but also it could not be expressed at all and that's cool.
 ? --> this part of the pattern is optional
 {x} --> must occur x number of times
 {x,y} --> must occur at least x times and at most y times
 {x,} --> must occur at least x times
 
 GROUPING SUBEXPRESSIONS
    let cartoonCrying = /boo+(hoo+)+/i;
    console.log(cartoonCrying.test("Boohoooohoohooo"));
    // → true
The first and second + allows the third o in booo and hooo and the third + allows multiple hooo or hoo

The i at the end of the expression makes it case INsensitive

MATCHES AND GROUPS
   exec (execute method) will return null if no match was found and return the match otherwise.
   index shows where within the original string the match is found
   let match = /\d+/.exec("one two 100");
      console.log(match);
      // → ["100"]
      console.log(match.index);
      // → 8
   for strings, a match method behaves similarly to the exec method mentioned above.
      console.log("one two 100".match(/\d+/));
      // → ["100"]
   Using exec with subexpressions --> returns an array whose first element matches the entires expression and whose second matches 
   only the sub expression (if multiple matches, the last will only be returned).
   
   DATE CLASS
    new Date(); --> returns current date and time
    console.log(new Date(2009, 11, 9));
      // → Wed Dec 09 2009 00:00:00 GMT+0100 (CET)
    getTime() --> outputs a date object that represents the number of milliseconds since the start of 1970  in the UTC time zone. 
    This is called "Unix time". 
    
    This example blends our understanding of RegExp with Date objects to produce a Date object from a given string input.
    
    WORD AND STRING BOUNDARIES
      Say we want to ensure that the match spans the whole string. Markers can be added to the start (^) and end ($) of the RegExp 
      to span the whole string.
        ex. /^\d+$/ will only match a string consisting ENTIRELY of digits
      Word boundaries are set using /b as start and /b as the end. Tests for presence of contained RegExp within the boundary.
    
    () CREATE A CAPTURE GROUP FOR EXTRACTING A SUBSTRING OR USING A BACKREFERENCE
    
    CHOICE PATTERNS
      Pipe character | represents an OR expression within the RegExp. Contained within parentheses, it limits the part of the pattern 
      that the pipe operator applies to. 
          let animalCount = /\b\d+ (pig|cow|chicken)s?\b/;
          console.log(animalCount.test("15 pigs"));
          // → true
          console.log(animalCount.test("15 pigchickens"));
          // → false
    
    BACKTRACKING
      This is how matching works... you should read the subsection.
    
    REPLACE METHOD
      let string = "potatoes";
      string.replace("p", "t");
      // -> totatoes
      
      The g option can be added to a regExp to replace ALL matches in the string, not just the first.
          console.log("Borobudur".replace(/[ou]/, "a"));
          // → Barobudur
          console.log("Borobudur".replace(/[ou]/g, "a"));
          // → Barabadar
      Say we want to swap the position of Lastname, Firstname to Firstname Lastname...
      the $1 will refer to the first parenthesized group in the pattern and the $2, the second.
                console.log(
            "Liskov, Barbara\nMcCarthy, John\nWadler, Philip"
              .replace(/(\w+), (\w+)/g, "$2 $1"));
          // → Barbara Liskov
          //   John McCarthy
          //   Philip Wadler
          
       Passing functions within the replace function-->
          The function will be called with the matched groups as argyments and the return value will be inserted into the new string
              let stock = "1 lemon, 2 cabbages, and 101 eggs";
              function minusOne(match, amount, unit) {
                amount = Number(amount) - 1;
                if (amount == 1) { // only one left, remove the 's'
                  unit = unit.slice(0, unit.length - 1);
                } else if (amount == 0) {
                  amount = "no";
                }
                return amount + " " + unit;
              }
              console.log(stock.replace(/(\d+) (\w+)/g, minusOne));
              // → no lemon, 1 cabbage, and 100 eggs
              
           
      
      
   
 
      
